% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gGnome.R
\name{eclusters2}
\alias{eclusters2}
\title{gGraph R6 public method eclusters2}
\usage{
eclusters2(
  thresh = 1000,
  weak = TRUE,
  paths = !weak,
  mc.cores = 1,
  verbose = FALSE,
  chunksize = 1e+30,
  method = "single",
  return_pairs = FALSE,
  ignore.small = TRUE,
  max.small = 10000,
  ignore.isolated = TRUE,
  strict = c("strict", "one_to_one", "loose"),
  min.isolated = max.small,
  only_chains = FALSE
)
}
\arguments{
\item{weak}{logical flag if TRUE will not differentiate between cycles and paths and will return all weakly connected clusters in the junction graph [FALSE]}

\item{mc.cores}{parallel}

\item{max.small}{size below which simple dups and dels are excluded}

\item{ignore.isolated}{If TRUE, all simple duplications, duplications nested with only other duplications, and simple deletions without any breakends will be thrown out.}

\item{strict}{Only active if only_chains = TRUE. Can be one of "strict", "one_to_one", or "loose". \cr
"strict": each breakend can only be "monogamously" matched to one other breakend and if the nearest breakend is of the wrong orientation, it is thrown out. \cr
"one_to_one" breakends can only be coupled to a single "monogamous" match but without considering breakends of the wrong orientation. If breakend B is nearest to C, B will only be matched to C. If A's nearest breakend is B but is further away than C, A will not be matched to B. \cr
"loose": the nearest breakend in the correct orientation under the threshold is considered. The same as one_to_one except A will be matched to B, while B will be matched to C. \cr}

\item{only_chains}{TRUE will only pair breakend to its nearest nearest neighbor IFF the nearest neighbor is reciprocal, see arguments to "strict" for 3 different matching heuristics}

\item{juncs}{GRangesList of junctions}
}
\value{
gGraph object with edges marked with ecluster id and metadata in gEdge, gNode, and $meta
}
\description{
Marks ALT edges belonging (quasi) reciprocal cycles
}
\author{
Marcin Imielinski
}
